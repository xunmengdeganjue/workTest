--- a/Makefile	2017-09-25 13:51:09.717832121 +0800
+++ b/Makefile	2017-09-22 15:02:43.935118633 +0800
@@ -46,7 +46,7 @@
 WEXT_HEADER = wireless.$(WE_VERSION).h
 
 # Targets to build
-STATIC=libiw.a
+STATIC=libiw.a logopt.a iwevent_stainfo.a
 DYNAMIC=libiw.so.$(WT_VERSION)
 PROGS= iwconfig iwlist iwpriv iwspy iwgetid iwevent ifrename
 MANPAGES8=iwconfig.8 iwlist.8 iwpriv.8 iwspy.8 iwgetid.8 iwevent.8 ifrename.8
@@ -55,7 +55,7 @@
 EXTRAPROGS= macaddr iwmulticall
 
 # Composition of the library :
-OBJS = iwlib.o
+OBJS = iwlib.o logopt.o iwevent_stainfo.o
 
 # Select which library to build and to link tool with
 ifdef BUILD_STATIC
@@ -114,7 +114,7 @@
 
 %: %.o
 	$(CC) $(LDFLAGS) $(STRIPFLAGS) $(XCFLAGS) -o $@ $^ $(LIBS)
-%.o: %.c wireless.h
+%.o: %.c wireless.h logopt.h iwevent.h
 	$(CC) $(XCFLAGS) -c $<
 %.so: %.c wireless.h
 	$(CC) $(XCFLAGS) $(PICFLAG) -c -o $@ $<
@@ -199,6 +199,10 @@
 	  ln -f -s iwconfig iwpriv ; \
 	  $(if $(BUILD_WE_ESSENTIAL),,ln -f -s iwconfig iwgetid ) )
 
+install-iwevent:: iwevent
+	install -m 755 -d $(INSTALL_DIR)
+	install -m 755 $< $(INSTALL_DIR)/iwevent
+
 clean::
 	$(RM_CMD) 
 
--- /dev/null	2017-09-22 09:24:14.476620199 +0800
+++ b/iwevent.h	2017-09-25 11:16:02.568276221 +0800
@@ -0,0 +1,388 @@
+/*
+*------------------------------------------------------------------------------
+*
+* Copyright (C) 2017-2018 by Sky Software Co.,Ltd. All rights reserved.
+* All source codes is distributed under the U-License.
+*
+* CPU:
+* RTOS:
+* Version: 0.1
+* Released by Sky Software Co.,Ltd
+* 2017/02/27.
+*
+*
+*
+* File Name : iwevent.h
+* Create Date : 2017/02/24
+* Author : Nick
+* Description :.
+*-------------------------------------------------------------------------------
+*/
+
+#ifndef __IWEVENT__H__
+#define __IWEVENT__H__
+
+#include <sys/socket.h>
+#include <sys/un.h> /*for   struct sockaddr_un*/
+#include <stdint.h>	
+
+#include "logopt.h"
+
+
+#define PRINTF_FORMAT(a,b)
+#define STRUCT_PACKED
+#define __force
+#define __bitwise
+#ifndef __func__
+#define __func__ __FUNCTION__
+#endif
+
+typedef uint64_t u64;
+typedef uint32_t u32;
+typedef uint16_t u16;
+typedef uint8_t u8;
+
+typedef int32_t s32;
+
+typedef u16 __bitwise be16;
+typedef u16 __bitwise le16;
+typedef u32 __bitwise be32;
+typedef u32 __bitwise le32;
+typedef u64 __bitwise be64;
+typedef u64 __bitwise le64;
+
+
+
+struct ieee80211_hdr {
+	le16 frame_control;
+	le16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	le16 seq_ctrl;
+	/* followed by 'u8 addr4[6];' if ToDS and FromDS is set in data frame
+	 */
+} STRUCT_PACKED;
+
+
+#define WLAN_SA_QUERY_TR_ID_LEN 2
+#ifndef ETH_ALEN
+#define ETH_ALEN 6
+#endif
+
+
+struct ieee80211_mgmt {
+	le16 frame_control;	/*2 bytes*/
+	le16 duration;		/*2 bytes*/
+	u8 da[6];			/*1 x 6 = 6 bytes*/
+	u8 sa[6];				/*1 x 6 = 6 bytes*/
+	u8 bssid[6];			/*1 x 6 = 6 bytes*/
+	le16 seq_ctrl;		/*2 bytes*/
+	union {
+		struct {
+			le16 auth_alg;
+			le16 auth_transaction;
+			le16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[];
+		} STRUCT_PACKED auth;
+		struct {
+			le16 reason_code;
+			u8 variable[];
+		} STRUCT_PACKED deauth;
+		struct {
+			le16 capab_info;
+			le16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[];
+		} STRUCT_PACKED assoc_req;
+		struct {
+			le16 capab_info;
+			le16 status_code;
+			le16 aid;
+			/* followed by Supported rates */
+			u8 variable[];
+		} STRUCT_PACKED assoc_resp, reassoc_resp;
+		struct {
+			le16 capab_info;
+			le16 listen_interval;
+			u8 current_ap[6];
+			/* followed by SSID and Supported rates */
+			u8 variable[];
+		} STRUCT_PACKED reassoc_req;
+		struct {
+			le16 reason_code;
+			u8 variable[];
+		} STRUCT_PACKED disassoc;
+		struct {
+			u8 timestamp[8];
+			le16 beacon_int;
+			le16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[];
+		} STRUCT_PACKED beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			u8 variable[0];
+		} STRUCT_PACKED probe_req;
+		struct {
+			u8 timestamp[8];
+			le16 beacon_int;
+			le16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[];
+		} STRUCT_PACKED probe_resp;
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[];
+				} STRUCT_PACKED wmm_action;
+				struct{
+					u8 action_code;
+					u8 element_id;
+					u8 length;
+					u8 switch_mode;
+					u8 new_chan;
+					u8 switch_count;
+				} STRUCT_PACKED chan_switch;
+				struct {
+					u8 action;
+					u8 sta_addr[ETH_ALEN];
+					u8 target_ap_addr[ETH_ALEN];
+					u8 variable[]; /* FT Request */
+				} STRUCT_PACKED ft_action_req;
+				struct {
+					u8 action;
+					u8 sta_addr[ETH_ALEN];
+					u8 target_ap_addr[ETH_ALEN];
+					le16 status_code;
+					u8 variable[]; /* FT Request */
+				} STRUCT_PACKED ft_action_resp;
+				struct {
+					u8 action;
+					u8 trans_id[WLAN_SA_QUERY_TR_ID_LEN];
+				} STRUCT_PACKED sa_query_req;
+				struct {
+					u8 action; /* */
+					u8 trans_id[WLAN_SA_QUERY_TR_ID_LEN];
+				} STRUCT_PACKED sa_query_resp;
+				struct {
+					u8 action;
+					u8 dialogtoken;
+					u8 variable[];
+				} STRUCT_PACKED wnm_sleep_req;
+				struct {
+					u8 action;
+					u8 dialogtoken;
+					le16 keydata_len;
+					u8 variable[];
+				} STRUCT_PACKED wnm_sleep_resp;
+				struct {
+					u8 action;
+					u8 variable[];
+				} STRUCT_PACKED public_action;
+				struct {
+					u8 action; /* 9 */
+					u8 oui[3];
+					/* Vendor-specific content */
+					u8 variable[];
+				} STRUCT_PACKED vs_public_action;
+				struct {
+					u8 action; /* 7 */
+					u8 dialog_token;
+					u8 req_mode;
+					le16 disassoc_timer;
+					u8 validity_interval;
+					/* BSS Termination Duration (optional),
+					 * Session Information URL (optional),
+					 * BSS Transition Candidate List
+					 * Entries */
+					u8 variable[];
+				} STRUCT_PACKED bss_tm_req;
+				struct {
+					u8 action; /* 8 */
+					u8 dialog_token;
+					u8 status_code;
+					u8 bss_termination_delay;
+					/* Target BSSID (optional),
+					 * BSS Transition Candidate List
+					 * Entries (optional) */
+					u8 variable[];
+				} STRUCT_PACKED bss_tm_resp;
+				struct {
+					u8 action; /* 6 */
+					u8 dialog_token;
+					u8 query_reason;
+					/* BSS Transition Candidate List
+					 * Entries (optional) */
+					u8 variable[];
+				} STRUCT_PACKED bss_tm_query;
+				struct {
+					u8 action; /* 15 */
+					u8 variable[];
+				} STRUCT_PACKED slf_prot_action;
+				struct {
+					u8 action;
+					u8 variable[];
+				} STRUCT_PACKED fst_action;
+			} u;
+		} STRUCT_PACKED action;
+	} u;
+} STRUCT_PACKED;
+
+
+#ifndef bswap_16
+#define bswap_16(a) ((((u16) (a) << 8) & 0xff00) | (((u16) (a) >> 8) & 0xff))
+#endif
+
+#ifndef __BYTE_ORDER
+#ifndef __LITTLE_ENDIAN
+#ifndef __BIG_ENDIAN
+#define __LITTLE_ENDIAN 1234
+#define __BIG_ENDIAN 4321
+#if defined(sparc)
+#define __BYTE_ORDER __BIG_ENDIAN
+#endif
+#endif /* __BIG_ENDIAN */
+#endif /* __LITTLE_ENDIAN */
+#endif /* __BYTE_ORDER */
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+/*now i know that rt4230w is the little_endian mode*/
+#define le_to_host16(n) ((__force u16) (le16) (n))
+
+#elif __BYTE_ORDER == __BIG_ENDIAN
+/*we know the arm is BIG_ENDIAN mode*/
+#define le_to_host16(n) bswap_16(n)
+
+#endif
+
+#define WLAN_FC_GET_TYPE(fc)	(((fc) & 0x000c) >> 2)
+#define WLAN_FC_GET_STYPE(fc)	(((fc) & 0x00f0) >> 4)
+
+#define WLAN_FC_TYPE_MGMT		0
+#define WLAN_FC_TYPE_CTRL		1
+#define WLAN_FC_TYPE_DATA		2
+
+/* management */
+#define WLAN_FC_STYPE_ASSOC_REQ		  0
+#define WLAN_FC_STYPE_ASSOC_RESP		1
+#define WLAN_FC_STYPE_REASSOC_REQ	2
+#define WLAN_FC_STYPE_REASSOC_RESP	3
+#define WLAN_FC_STYPE_PROBE_REQ 		4
+#define WLAN_FC_STYPE_PROBE_RESP		5
+#define WLAN_FC_STYPE_BEACON			8
+#define WLAN_FC_STYPE_ATIM			9
+#define WLAN_FC_STYPE_DISASSOC		10
+#define WLAN_FC_STYPE_AUTH			11
+#define WLAN_FC_STYPE_DEAUTH			12
+#define WLAN_FC_STYPE_ACTION			13
+
+#define IEEE80211_HDRLEN (sizeof(struct ieee80211_hdr))
+
+#ifndef MAC2STR
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR  "%02x:%02x:%02x:%02x:%02x:%02x"
+#endif
+
+/******************************2017-02-24***************************************/
+#if 0
+/* Element ID  */
+#define IEEE80211_ELEMID_RSN 48
+#define IEEE80211_ELEMID_VENDOR 221
+#define IEEE80211_CAPINFO_PRIVACY           0x0010
+#endif
+
+#define IEEE80211_ADDR_LEN  		6       /* size of 802.11 address */
+#define IEEE80211_RATE_MAXSIZE  	44      /* max rates we'll handle */
+#define IEEE80211_RATE_VAL             	0x7f
+
+/*
+ * Station information block; the mac address is used
+ * to retrieve other data like stats, unicast key, etc.
+ */
+struct ieee80211req_sta_info {
+		u_int16_t		isi_len;				/* length (mult of 4) */
+		u_int16_t		isi_freq;				/* MHz */
+		u_int32_t		awake_time; 			/* time is active mode */
+		u_int32_t		ps_time;				/* time in power save mode */
+		u_int32_t		isi_flags;		/* channel flags */
+		u_int16_t		isi_state;				/* state flags */
+		u_int8_t		isi_authmode;			/* authentication algorithm */
+		int8_t			isi_rssi;
+		int8_t			isi_min_rssi;
+		int8_t			isi_max_rssi;
+		u_int16_t		isi_capinfo;			/* capabilities */
+		u_int8_t		isi_athflags;			/* Atheros capabilities */
+		u_int8_t		isi_erp;				/* ERP element */
+		u_int8_t		isi_ps; 		/* psmode */
+		u_int8_t		isi_macaddr[IEEE80211_ADDR_LEN];
+		u_int8_t		isi_nrates;
+												/* negotiated rates */
+		u_int8_t		isi_rates[IEEE80211_RATE_MAXSIZE];
+		u_int8_t		isi_txrate; 			/* index to isi_rates[] */
+		u_int32_t		isi_txratekbps; /* tx rate in Kbps, for 11n */
+		u_int16_t		isi_ie_len; 			/* IE length */
+		u_int16_t		isi_associd;			/* assoc response */
+		u_int16_t		isi_txpower;			/* current tx power */
+		u_int16_t		isi_vlan;				/* vlan tag */
+		u_int16_t		isi_txseqs[17]; 		/* seq to be transmitted */
+		u_int16_t		isi_rxseqs[17]; 		/* seq previous for qos frames*/
+		u_int16_t		isi_inact;				/* inactivity timer */
+		u_int8_t		isi_uapsd;				/* UAPSD queues */
+		u_int8_t		isi_opmode; 			/* sta operating mode */
+		u_int8_t		isi_cipher;
+		u_int32_t		isi_assoc_time; 		/* sta association time */
+		struct timespec isi_tr069_assoc_time;	/* sta association time in timespec format */
+
+
+		u_int16_t	isi_htcap;		/* HT capabilities */
+		u_int32_t	isi_rxratekbps; /* rx rate in Kbps */
+								/* We use this as a common variable for legacy rates
+								   and lln. We do not attempt to make it symmetrical
+								   to isi_txratekbps and isi_txrate, which seem to be
+								   separate due to legacy code. */
+		/* XXX frag state? */
+		/* variable length IE data */
+		u_int8_t isi_maxrate_per_client; /* Max rate per client */
+		u_int16_t	isi_stamode;		/* Wireless mode for connected sta */
+		u_int32_t isi_ext_cap;				/* Extended capabilities */
+		u_int8_t isi_nss;		  /* number of tx and rx chains */
+		u_int8_t isi_is_256qam;    /* 256 QAM support */
+		u_int8_t isi_operating_bands : 2; /* Operating bands */
+#if ATH_SUPPORT_EXT_STAT
+		u_int8_t  isi_chwidth;			  /* communication band width */
+		u_int32_t isi_vhtcap;			  /* VHT capabilities */
+#endif
+		u_int8_t isi_rx_nss;		 /* number of rx chains */
+		u_int8_t isi_tx_nss;		 /* number of tx chains */
+};
+
+
+
+t_log_p logopt_stainfo;
+#define LOG_STA_FILE				"/tmp/historical_stations.log"
+
+#define log_sta_info(fmt,...) \
+	do { \
+		debug_log_print(logopt_stainfo, eLOG_LEVEL_INFOR, NULL, \
+			0, 0, (fmt), ##__VA_ARGS__); \
+	} while(0)
+
+#define log_stainfo_init() \
+	debug_log_init(&logopt_stainfo, LOG_STA_FILE, 0, LOG_LEVEL)
+
+int finde_dest_stations(const char *ifname, const char *statocheck);
+
+
+#endif  /*__IWEVENT__H__*/
+
+
+
+
--- /dev/null	2017-09-22 09:24:14.476620199 +0800
+++ b/iwevent_stainfo.c	2017-09-25 13:18:10.872117385 +0800
@@ -0,0 +1,168 @@
+/*
+*------------------------------------------------------------------------------
+*
+* Copyright (C) 2017-2018 by Sky Software Co.,Ltd. All rights reserved.
+* All source codes is distributed under the U-License.
+*
+* CPU:
+* RTOS:
+* Version: 0.1
+* Released by Sky Software Co.,Ltd
+* 2017/02/27.
+*
+*
+*
+* File Name : iwevent_stainfo.c
+* Create Date : 2017/02/24
+* Author : Nick
+* Description :The sub-functions related to the historical clients of the AP.
+*-------------------------------------------------------------------------------
+*/
+#include "iwlib.h"
+#include "iwevent.h"
+#include "logopt.h"
+//#include <linux/wireless.h>
+
+
+#define	IEEE80211_IOCTL_STA_INFO	(SIOCDEVPRIVATE+6)
+#define	LIST_STATION_ALLOC_SIZE 24*1024
+
+
+static const char * ieee80211_ntoa(const uint8_t mac[IEEE80211_ADDR_LEN])
+{
+	static char a[18];
+	int i;
+
+	i = snprintf(a, sizeof(a), "%02x:%02x:%02x:%02x:%02x:%02x",
+		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	return (i < 17 ? NULL : a);
+}
+
+/*
+* Function Name : finde_dest_stations
+* Create Date : 2017/02/24
+* Author : Nick
+* Description : check if the dest station has associated to the AP.
+* Param : 
+	(1)ifname : the dest interface of the ap.
+	(2)statocheck : the dest station to be checked.
+* Output:
+* Input:
+* Return Code : 
+	(1) 0 :the station has not associated to the AP.
+	(2) 1 :the station has associated to the AP.
+*/
+int finde_dest_stations(const char *ifname, const char *statocheck)
+{
+	log_trace_enter();
+
+	uint8_t *buf;
+	struct iwreq iwr;
+	uint8_t *cp;
+	int s;
+	u_int32_t txrate, rxrate = 0, maxrate = 0;
+	u_int32_t time_val=0, hour_val=0, min_val=0, sec_val=0;
+	const char *ntoa = NULL;
+	int req_space = 0;
+	u_int64_t len = 0;
+
+	buf = malloc(LIST_STATION_ALLOC_SIZE);
+	if(!buf) {
+		fprintf (stderr, "Unable to allocate memory for station list\n");
+		return 0;
+	}
+
+	log_dbg("the interface = [%s]\n",ifname);
+	
+	
+	s = socket(AF_INET, SOCK_DGRAM, 0);
+	if (s < 0){
+		free(buf);
+		log_err("socket(SOCK_DRAGM)\n");
+		return 0;
+	}
+
+	if (!strncmp(ifname, "wifi", 4)) {
+		free(buf);
+		close(s);
+		log_err("Not a valid interface\n");
+		return 0;
+	}
+
+	(void) memset(&iwr, 0, sizeof(iwr));
+	(void) strncpy(iwr.ifr_name, ifname, sizeof(iwr.ifr_name));
+	iwr.u.data.pointer = (void *) buf;
+	iwr.u.data.length = LIST_STATION_ALLOC_SIZE;
+	iwr.u.data.flags = 0;
+	//Support for 512 client
+	req_space = ioctl(s, IEEE80211_IOCTL_STA_INFO, &iwr);
+	if (req_space < 0 ){
+		free(buf);
+		log_err("unable to get station information\n");
+		return 0;
+	}
+	else if(req_space > 0) {
+		free(buf);
+		buf = malloc(req_space);
+		if(!buf) {
+			log_err("Unable to allocate memory for station list\n");
+			return 0;
+		}
+		iwr.u.data.pointer = (void *) buf;
+		iwr.u.data.length = req_space;
+		if(iwr.u.data.length < req_space)
+			iwr.u.data.flags = 1;
+		if (ioctl(s, IEEE80211_IOCTL_STA_INFO, &iwr) < 0 ){
+			free(buf);
+			log_err("unable to get station information\n");
+		}
+		len = req_space;
+
+	}
+	else {
+		log_trace_line();
+		len = iwr.u.data.length;
+	}
+
+	if (len < sizeof(struct ieee80211req_sta_info)){
+		free(buf);
+		close(s);
+		return 0;
+	}
+	
+	cp = buf;
+	
+	do {
+		log_trace_line();
+		
+		struct ieee80211req_sta_info *si;
+		uint8_t *vp;
+
+		si = (struct ieee80211req_sta_info *) cp;		
+		ntoa = ieee80211_ntoa(si->isi_macaddr);
+
+		log_dbg("the dest client\033[33m[%s]\033[0m\n",statocheck);
+		log_dbg("the got client \033[33m[%s]\033[0m\n",ntoa);
+
+		if(ntoa){
+			if(!strcmp(ntoa,statocheck)){
+				free(buf);
+				log_trace_line();
+				return 1;
+			}
+
+		}
+
+		cp += si->isi_len, len -= si->isi_len;
+		log_trace_line();
+	} while (len >= sizeof(struct ieee80211req_sta_info));
+
+	free(buf);
+	
+	close(s);
+	
+	log_trace_exit();
+	return 0;
+
+	
+}
--- /dev/null	2017-09-22 09:24:14.476620199 +0800
+++ b/logopt.h	2017-09-22 15:02:44.059118577 +0800
@@ -0,0 +1,94 @@
+ /**
+	@file log_for_debug.h
+**/ 
+
+#ifndef __LOG_OPT_H__
+#define __LOG_OPT_H__
+
+
+/* Include files. */
+
+/* Macro constant definitions. */
+#define LOG_FILE				"/var/log/iwevent.log"
+
+
+/** default iwevent log debug level */
+#define LOG_LEVEL							eLOG_LEVEL_TRACE
+#define LOG_DEBUG_DEFAULT_LEVEL			eLOG_LEVEL_ERROR
+#define LOG_DEBUG_DEFAULT_BUF_LEN		128
+#define LOG_DEBUG_FILE_SIZE				(1024 * 1024) /*1M*/
+
+/* Type definitions. */
+
+enum e_log_level{
+	eLOG_LEVEL_CRITICAL = 1,
+	eLOG_LEVEL_ERROR,
+	eLOG_LEVEL_WARNING,
+	eLOG_LEVEL_INFOR ,
+	eLOG_LEVEL_DEBUG ,
+	eLOG_LEVEL_TRACE ,
+};
+
+typedef struct debug_log *t_log_p;
+
+/* External function declarations. */
+
+extern int debug_log_init(t_log_p * log_p, const char *log_file, unsigned long attr, int init_level);
+extern int debug_log_print(t_log_p log, int level, const char *func,
+			   const char *file, unsigned long line, const char *fmt, ...);
+extern void debug_log_clean(t_log_p * log_p);
+
+/* Macro API definitions. */
+/** opt log pointer */
+t_log_p logopt_log;
+
+/* Macro API definitions. */
+
+#define log_crit(fmt,...) \
+		do { \
+			debug_log_print(logopt_log, eLOG_LEVEL_CRITICAL, __FUNCTION__, \
+				__FILE__, __LINE__, (fmt), ##__VA_ARGS__); \
+		} while(0)
+
+#define log_err(fmt,...) \
+	do { \
+		debug_log_print(logopt_log, eLOG_LEVEL_ERROR, __FUNCTION__, \
+			__FILE__, __LINE__, (fmt), ##__VA_ARGS__); \
+	} while(0)
+
+#define log_info(fmt,...) \
+	do { \
+		debug_log_print(logopt_log, eLOG_LEVEL_INFOR, __FUNCTION__, \
+			__FILE__, __LINE__, (fmt), ##__VA_ARGS__); \
+	} while(0)
+
+#define log_dbg(fmt,...) \
+	do { \
+		debug_log_print(logopt_log, eLOG_LEVEL_DEBUG, __FUNCTION__, \
+			__FILE__, __LINE__, (fmt), ##__VA_ARGS__); \
+	} while(0)
+
+#define log_trace_enter() \
+	do { \
+		debug_log_print(logopt_log, eLOG_LEVEL_TRACE, __FUNCTION__, \
+			__FILE__, __LINE__, "[ENTER]\n"); \
+	} while(0)
+
+#define log_trace_exit() \
+	do { \
+		debug_log_print(logopt_log, eLOG_LEVEL_TRACE, __FUNCTION__, \
+			__FILE__, __LINE__, "[EXIT]\n"); \
+	} while(0)
+
+#define log_trace_line() \
+	do { \
+		debug_log_print(logopt_log, eLOG_LEVEL_TRACE, __FUNCTION__, \
+			__FILE__, __LINE__, "[CHECK]\n"); \
+	} while(0)
+
+#define log_dbg_init() \
+	debug_log_init(&logopt_log, LOG_FILE, 0, LOG_LEVEL)
+	
+/* Global variable declarations. */
+
+#endif				/* __LOG_OPT_H__ */
\ No newline at end of file
--- /dev/null	2017-09-22 09:24:14.476620199 +0800
+++ b/logopt.c	2017-09-22 15:02:44.051118580 +0800
@@ -0,0 +1,242 @@
+/**
+	@file logopt.c
+**/ 
+
+/* Include files. */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <time.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+
+#include "logopt.h"
+
+/* Macro constant definitions. */
+
+#define CON_COLOR_GREEN         	"\033[1;32m"
+#define CON_COLOR_RED           	"\033[1;31m"
+#define CON_COLOR_PURPLE        	"\033[1;35m"
+#define CON_COLOR_YELLOW        	"\033[1;33m"
+#define CON_COLOR_CYAN          	"\033[1;36m"
+#define CON_COLOR_END				"\033[m"
+
+#define LOGIN_USER				"system.sauth.login_user"
+
+/* Type definitions. */
+
+typedef struct debug_log {
+	FILE *fp;
+	unsigned char use_stdout;
+	unsigned int level;
+	unsigned long attr;
+	unsigned long msg_buf_len;
+	char *msg_buf;
+	char *log_filename;
+} t_log;
+
+/* Local function declarations. */
+
+/* Macro API definitions. */
+
+/* Global variable declarations. */
+
+int debug_log_init(t_log_p * log_p, const char *log_file, unsigned long attr, int init_level)
+{
+
+	t_log_p log;
+	char tmparray[128] = {0};
+	char command[128] = {0};
+
+	FILE *pf = NULL;
+	int ret = 0;
+	
+	log = malloc(sizeof(t_log));
+	if (log == NULL) {
+		return (-1);
+	}
+	
+	
+	if (log_file != NULL) {
+		log->fp = fopen(log_file, "a+");
+		if (log->fp == NULL) {
+			fprintf(stderr, "Open[%s] failed, USE Stdout as debug output.\n", log_file);
+			log->log_filename = NULL;
+			log->use_stdout = 1;
+			log->fp = stdout;
+		} else {
+			log->log_filename = strdup(log_file);
+			log->use_stdout = 0;
+		}
+	} else {
+		fprintf(stderr, "USE Stdout as debug output.\n");
+		log->use_stdout = 1;
+		log->log_filename = NULL;
+		log->fp = stdout;
+	}
+
+	log->msg_buf_len = LOG_DEBUG_DEFAULT_BUF_LEN;
+	log->msg_buf = malloc(log->msg_buf_len);
+	if (log->msg_buf == NULL) {
+		if (log->log_filename) {
+			free(log->log_filename);
+		}
+		if (!log->use_stdout) {
+		fclose(log->fp);
+		}
+		free(log);
+		return (-2);
+	}
+
+	log->level = init_level;
+	log->attr = attr;
+
+	*log_p = log;
+
+	return (0);
+}
+
+static inline void _get_time(char *buff, int buff_len)
+{
+	struct timeval tv = { 0 };
+	struct tm *time_v = NULL, time_value = { 0 };
+
+	gettimeofday(&tv, NULL);
+	/* time_v = localtime(&tv.tv_sec); */
+	time_v = localtime_r(&tv.tv_sec, &time_value);
+	if (NULL != time_v) {
+		snprintf(buff, buff_len, "%d-%02d-%02d %02d:%02d:%02d ",
+			 time_v->tm_year + 1900, time_v->tm_mon + 1,
+			 time_v->tm_mday, time_v->tm_hour, time_v->tm_min, time_v->tm_sec);
+	}
+}
+
+int debug_log_print(t_log_p log, int level, const char *func,
+		    const char *file, unsigned long line, const char *fmt, ...)
+{
+	va_list args;
+	int rc = 0;
+	int buf_len;
+	char *new_buf;
+	char time[64];
+	long fsize;
+
+	if ((level <= LOG_DEBUG_DEFAULT_LEVEL) || (level <= log->level)) {
+		_get_time(time, sizeof(time));
+		if (!log->use_stdout) {
+			fsize = ftell(log->fp);
+			if (fsize > LOG_DEBUG_FILE_SIZE) {
+				int fd;
+				fclose(log->fp);
+				fd = open(log->log_filename, O_CREAT | O_WRONLY | O_TRUNC | O_APPEND, 0666);
+				if (fd >= 0) {
+					close(fd);
+				}
+				log->fp = fopen(log->log_filename, "w+");
+				if (log->fp == NULL) {
+					log->fp = stdout;
+					log->use_stdout = 1;
+				}
+				fprintf(log->fp, "%s" CON_COLOR_RED "[!!!!!!]" CON_COLOR_END
+					CON_COLOR_RED " FILE truncate!(size: %ld)" CON_COLOR_END "\n", time, fsize);
+			}
+		}
+
+		va_start(args, fmt);
+		do {
+			buf_len = log->msg_buf_len;
+			rc = vsnprintf(log->msg_buf, log->msg_buf_len, fmt, args);
+			if (rc >= buf_len) {
+				//printf("Need relloc buf to %lu\n", log->msg_buf_len);
+				new_buf = malloc(buf_len * 2);
+				if (new_buf == NULL) {
+					break;
+				} else {
+					free(log->msg_buf);
+					log->msg_buf = new_buf;
+					log->msg_buf_len = buf_len * 2;
+				}
+			}
+		} while (rc >= buf_len);
+		va_end(args);
+
+#define LINE_FILE_FUNC_FMT   "[%4lu][%-25s]"
+
+		switch (level) {
+		case eLOG_LEVEL_TRACE:
+			rc = fprintf(log->fp, "%s" CON_COLOR_GREEN "[TRACE]" CON_COLOR_END
+				     CON_COLOR_CYAN LINE_FILE_FUNC_FMT CON_COLOR_END CON_COLOR_GREEN
+				     " %s" CON_COLOR_END, time, line, func, log->msg_buf);
+			break;
+		case eLOG_LEVEL_DEBUG:
+			rc = fprintf(log->fp, "%s" CON_COLOR_GREEN "[DEBUG]" CON_COLOR_END
+				     CON_COLOR_CYAN LINE_FILE_FUNC_FMT CON_COLOR_END CON_COLOR_GREEN
+				     " %s" CON_COLOR_END, time, line, func, log->msg_buf);
+			break;
+		case eLOG_LEVEL_INFOR:
+			if(line){
+				rc = fprintf(log->fp, "%s" CON_COLOR_YELLOW "[INFO ]" CON_COLOR_END
+				     CON_COLOR_CYAN LINE_FILE_FUNC_FMT CON_COLOR_END CON_COLOR_YELLOW
+				     " %s" CON_COLOR_END, time, line, func, log->msg_buf);
+			}else{
+				rc = fprintf(log->fp, "%s  %s" , time, log->msg_buf);
+			}	
+			break;
+		case eLOG_LEVEL_WARNING:
+			rc = fprintf(log->fp, "%s" CON_COLOR_PURPLE "[WARN ]" CON_COLOR_END
+				     CON_COLOR_CYAN LINE_FILE_FUNC_FMT CON_COLOR_END CON_COLOR_PURPLE
+				     " %s" CON_COLOR_END, time, line, func, log->msg_buf);
+			break;
+		case eLOG_LEVEL_ERROR:
+			rc = fprintf(log->fp, "%s" CON_COLOR_RED "[ERROR]" CON_COLOR_END
+				     CON_COLOR_CYAN LINE_FILE_FUNC_FMT CON_COLOR_END CON_COLOR_RED
+				     " %s" CON_COLOR_END, time, line, func, log->msg_buf);
+			break;
+		case eLOG_LEVEL_CRITICAL:
+			rc = fprintf(log->fp, "%s" CON_COLOR_RED "[!!!!!]" CON_COLOR_END
+				     CON_COLOR_CYAN LINE_FILE_FUNC_FMT CON_COLOR_END CON_COLOR_RED
+				     " %s" CON_COLOR_END, time, line, func, log->msg_buf);
+			break;
+		default:
+			rc = fprintf(log->fp, "%s[DEBUG]" LINE_FILE_FUNC_FMT "%s",
+				     time, line, func, log->msg_buf);
+			break;
+		}
+#undef LINE_FILE_FUNC_FMT
+		fflush(log->fp);
+	}
+
+	return (rc);
+}
+
+void debug_log_clean(t_log_p * log_p)
+{
+	t_log_p log = *log_p;
+
+	if (log != NULL) {
+		log->msg_buf_len = 0;
+
+		if (log->msg_buf != NULL) {
+			free(log->msg_buf);
+			log->msg_buf = NULL;
+		}
+
+		if ((!log->use_stdout) && (log->fp != NULL)) {
+			fclose(log->fp);
+			log->fp = NULL;
+		}
+
+		if (log->log_filename != NULL) {
+			free(log->log_filename);
+			log->log_filename = NULL;
+		}
+		free(log);
+	}
+	*log_p = NULL;
+}
\ No newline at end of file

--- a/iwevent.c	2018-08-24 13:48:28.293974295 +0800
+++ b/iwevent.c	2018-08-24 13:52:33.846644736 +0800
@@ -26,6 +26,9 @@
 #include <time.h>
 #include <sys/time.h>
 
+#include "logopt.h"
+#include "iwevent.h"
+
 /* Ugly backward compatibility :-( */
 #ifndef IFLA_WIRELESS
 #define IFLA_WIRELESS	(IFLA_MASTER + 1)
@@ -39,16 +42,16 @@
  */
 typedef struct wireless_iface
 {
-  /* Linked list */
-  struct wireless_iface *	next;
+	/* Linked list */
+	struct wireless_iface *	next;
 
-  /* Interface identification */
-  int		ifindex;		/* Interface index == black magic */
+	/* Interface identification */
+	int		ifindex;		/* Interface index == black magic */
 
-  /* Interface data */
-  char			ifname[IFNAMSIZ + 1];	/* Interface name */
-  struct iw_range	range;			/* Wireless static data */
-  int			has_range;
+	/* Interface data */
+	char			ifname[IFNAMSIZ + 1];	/* Interface name */
+	struct iw_range	range;			/* Wireless static data */
+	int			has_range;
 } wireless_iface;
 
 /**************************** VARIABLES ****************************/
@@ -56,6 +59,8 @@
 /* Cache of wireless interfaces */
 struct wireless_iface *	interface_cache = NULL;
 
+int decimal_tx_power = 0;
+
 /************************ RTNETLINK HELPERS ************************/
 /*
  * The following code is extracted from :
@@ -146,19 +151,19 @@
 	   int		ifindex,
 	   char *	name)
 {
-  struct ifreq	irq;
-  int		ret = 0;
+	struct ifreq	irq;
+	int		ret = 0;
 
-  memset(name, 0, IFNAMSIZ + 1);
+	memset(name, 0, IFNAMSIZ + 1);
 
-  /* Get interface name */
-  irq.ifr_ifindex = ifindex;
-  if(ioctl(skfd, SIOCGIFNAME, &irq) < 0)
-    ret = -1;
-  else
-    strncpy(name, irq.ifr_name, IFNAMSIZ);
+	/* Get interface name */
+	irq.ifr_ifindex = ifindex;
+	if(ioctl(skfd, SIOCGIFNAME, &irq) < 0)
+		ret = -1;
+	else
+		strncpy(name, irq.ifr_name, IFNAMSIZ);
 
-  return(ret);
+	return(ret);
 }
 
 /*------------------------------------------------------------------*/
@@ -168,60 +173,60 @@
 static struct wireless_iface *
 iw_get_interface_data(int	ifindex)
 {
-  struct wireless_iface *	curr;
-  int				skfd = -1;	/* ioctl socket */
+	struct wireless_iface *	curr;
+	int				skfd = -1;	/* ioctl socket */
 
-  /* Search for it in the database */
-  curr = interface_cache;
-  while(curr != NULL)
-    {
-      /* Match ? */
-      if(curr->ifindex == ifindex)
+	/* Search for it in the database */
+	curr = interface_cache;
+	while(curr != NULL)
 	{
-	  //printf("Cache : found %d-%s\n", curr->ifindex, curr->ifname);
+		/* Match ? */
+		if(curr->ifindex == ifindex)
+		{
+			//printf("Cache : found %d-%s\n", curr->ifindex, curr->ifname);
 
-	  /* Return */
-	  return(curr);
+			/* Return */
+			return(curr);
+		}
+		/* Next entry */
+		curr = curr->next;
 	}
-      /* Next entry */
-      curr = curr->next;
-    }
 
-  /* Create a channel to the NET kernel. Doesn't happen too often, so
-   * socket creation overhead is minimal... */
-  if((skfd = iw_sockets_open()) < 0)
-    {
-      perror("iw_sockets_open");
-      return(NULL);
-    }
+	/* Create a channel to the NET kernel. Doesn't happen too often, so
+	* socket creation overhead is minimal... */
+	if((skfd = iw_sockets_open()) < 0)
+	{
+		perror("iw_sockets_open");
+		return(NULL);
+	}
 
-  /* Create new entry, zero, init */
-  curr = calloc(1, sizeof(struct wireless_iface));
-  if(!curr)
-    {
-      fprintf(stderr, "Malloc failed\n");
-      return(NULL);
-    }
-  curr->ifindex = ifindex;
+	/* Create new entry, zero, init */
+	curr = calloc(1, sizeof(struct wireless_iface));
+	if(!curr)
+	{
+		fprintf(stderr, "Malloc failed\n");
+		return(NULL);
+	}
+	curr->ifindex = ifindex;
 
-  /* Extract static data */
-  if(index2name(skfd, ifindex, curr->ifname) < 0)
-    {
-      perror("index2name");
-      free(curr);
-      return(NULL);
-    }
-  curr->has_range = (iw_get_range_info(skfd, curr->ifname, &curr->range) >= 0);
-  //printf("Cache : create %d-%s\n", curr->ifindex, curr->ifname);
+	/* Extract static data */
+	if(index2name(skfd, ifindex, curr->ifname) < 0)
+	{
+		perror("index2name");
+		free(curr);
+		return(NULL);
+	}
+	curr->has_range = (iw_get_range_info(skfd, curr->ifname, &curr->range) >= 0);
+	//printf("Cache : create %d-%s\n", curr->ifindex, curr->ifname);
 
-  /* Done */
-  iw_sockets_close(skfd);
+	/* Done */
+	iw_sockets_close(skfd);
 
-  /* Link it */
-  curr->next = interface_cache;
-  interface_cache = curr;
+	/* Link it */
+	curr->next = interface_cache;
+	interface_cache = curr;
 
-  return(curr);
+	return(curr);
 }
 
 /*------------------------------------------------------------------*/
@@ -231,38 +236,38 @@
 static void
 iw_del_interface_data(int	ifindex)
 {
-  struct wireless_iface *	curr;
-  struct wireless_iface *	prev = NULL;
-  struct wireless_iface *	next;
-
-  /* Go through the list, find the interface, kills it */
-  curr = interface_cache;
-  while(curr)
-    {
-      next = curr->next;
-
-      /* Got a match ? */
-      if(curr->ifindex == ifindex)
-	{
-	  /* Unlink. Root ? */
-	  if(!prev)
-	    interface_cache = next;
-	  else
-	    prev->next = next;
-	  //printf("Cache : purge %d-%s\n", curr->ifindex, curr->ifname);
+	struct wireless_iface *	curr;
+	struct wireless_iface *	prev = NULL;
+	struct wireless_iface *	next;
+
+	/* Go through the list, find the interface, kills it */
+	curr = interface_cache;
+	while(curr)
+	{
+		next = curr->next;
+
+		/* Got a match ? */
+		if(curr->ifindex == ifindex)
+		{
+			/* Unlink. Root ? */
+			if(!prev)
+				interface_cache = next;
+			else
+				prev->next = next;
+				//printf("Cache : purge %d-%s\n", curr->ifindex, curr->ifname);
+
+			/* Destroy */
+			free(curr);
+		}
+		else
+		{
+			/* Keep as previous */
+			prev = curr;
+		}
 
-	  /* Destroy */
-	  free(curr);
+		/* Next entry */
+		curr = next;
 	}
-      else
-	{
-	  /* Keep as previous */
-	  prev = curr;
-	}
-
-      /* Next entry */
-      curr = next;
-    }
 }
 
 /********************* WIRELESS EVENT DECODING *********************/
@@ -282,14 +287,95 @@
 	   const unsigned char *data,
 	   size_t		datalen)
 {
-  size_t	i;
-  char *	pos = buf;
+	size_t	i;
+	char *	pos = buf;
 
-  for(i = 0; i < datalen; i++)
-    pos += snprintf(pos, buf + buflen - pos, "%02X", data[i]);
-  return buf;
+	for(i = 0; i < datalen; i++)
+		pos += snprintf(pos, buf + buflen - pos, "%02X", data[i]);
+	return buf;
+}
+
+/*
+this function is do the work like atheros_raw_receive  in the hostapd.
+*/
+static void event_to_custom( const u8 *custom,int len,int flags,char *ifname){
+	const struct ieee80211_mgmt *mgmt;
+	u16 fc, stype;
+	int ielen;
+	const u8 *iebuf;
+	log_trace_enter();
+	char buffer[1024]= {0};//just for debug
+	char show_buffer[1024]={0};//just for debug
+	
+	log_dbg("The custom is [%s]\n",custom);
+
+	memcpy(show_buffer,custom,len);
+	/*here we should fill the custom to the struct mgfm*/
+	if(len<IEEE80211_HDRLEN){
+		log_err("THE length of the header is[%d] too short",len);
+		return ;
+	}
+	
+	mgmt = (const struct ieee80211_mgmt *)custom;
+	fc = le_to_host16(mgmt->frame_control);
+	if (WLAN_FC_GET_TYPE(fc) != WLAN_FC_TYPE_MGMT){
+		log_trace_line();
+		return;
+	}
+	stype = WLAN_FC_GET_STYPE(fc);
+	log_dbg("subtype=[%d],len=[%d]\n",stype,len);
+	if (stype == WLAN_FC_STYPE_PROBE_REQ) {
+		/*TBD:by now we have no time to extend this function*/
+		log_info("The subtype is WLAN_FC_STYPE_PROBE_REQ[%d]\n",WLAN_FC_STYPE_PROBE_REQ);
+	}
+	switch (stype) {
+		case WLAN_FC_STYPE_ASSOC_REQ:
+			if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.assoc_req)){
+				log_err("the len is little than IEEE80211_HDRLEN + sizeof((mgmt->u.assoc_req)\n");
+				break;
+			}
+			log_dbg("hexdump[\033[35m%s\033[0m]\n",iw_hexdump(buffer,sizeof(buffer),show_buffer,len));
+			log_dbg("GET THE \"\033[35mASSOC REQUEST\033[0m\"\n");
+			
+			ielen = len - (IEEE80211_HDRLEN + sizeof(mgmt->u.assoc_req));
+			iebuf = mgmt->u.assoc_req.variable;
+			
+			log_dbg("The client Mac=[\033[35m%02x:%02x:%02x:%02x:%02x:%02x\033[0m]\n",MAC2STR(mgmt->sa));
+			//sleep(5);
+			
+			char dest_client[18]={0};
+			sprintf(dest_client,"%02x:%02x:%02x:%02x:%02x:%02x",MAC2STR(mgmt->sa));
+
+			if(finde_dest_stations(ifname, (const char *)dest_client)){
+				log_dbg("THE STATION ASSOCIATED SUCCESSFULLY\n");
+				log_sta_info("[VAP:%s] [STA::%s] associated\n",ifname,dest_client);
+			}else{
+				sleep(3);
+				if(finde_dest_stations(ifname, (const char *)dest_client)){
+					log_dbg("\033[35mTHE STATION ASSOCIATED SUCCESSFULLY\033[0m\n");
+					log_sta_info("VAP:%s] [STA::%s] associated\n",dest_client);
+				}else{
+					log_dbg("\033[31mTHE STATION ASSOCIATED FAILED\033[0m\n");
+				}
+			}
+			break;
+		case WLAN_FC_STYPE_REASSOC_REQ:
+			log_dbg("\033[33mNICK:[%s]:hexdump[%s]\033[0m\n",__func__,iw_hexdump(buffer,sizeof(buffer),show_buffer,len));
+			log_dbg("\033[36mNICK:[%s]:GET THE \"REASSOC REQEST\" EVENT\033[0m\n",__func__);
+			break;
+		case WLAN_FC_STYPE_ACTION:
+			log_dbg("\033[31mNICK:[%s]:hexdump[%s]\033[0m\n",__func__,iw_hexdump(buffer,sizeof(buffer),show_buffer,len));
+			log_dbg("\033[36mNICK:[%s]:GET THE \"ACTION\" EVENT\033[0m\n",__func__);
+			break;
+		case WLAN_FC_STYPE_AUTH:
+			log_dbg("\033[32mNICK:[%s]:hexdump[%s]\033[0m\n",__func__,iw_hexdump(buffer,sizeof(buffer),show_buffer,len));
+			log_dbg("\033[36mNICK:[%s]:GET THE \"AUTH\" EVENT\033[0m\n",__func__);
+			break;
+		default:
+			break;	
+	}
+	log_trace_exit();
 }
-
 /*------------------------------------------------------------------*/
 /*
  * Print one element from the scanning results
@@ -297,196 +383,238 @@
 static inline int
 print_event_token(struct iw_event *	event,		/* Extracted token */
 		  struct iw_range *	iw_range,	/* Range info */
-		  int			has_range)
+		  int			has_range, char * ifname)
 {
-  char		buffer[128];	/* Temporary buffer */
-  char		buffer2[30];	/* Temporary buffer */
-  char *	prefix = (IW_IS_GET(event->cmd) ? "New" : "Set");
-
-  /* Now, let's decode the event */
-  switch(event->cmd)
-    {
-      /* ----- set events ----- */
-      /* Events that result from a "SET XXX" operation by the user */
-    case SIOCSIWNWID:
-      if(event->u.nwid.disabled)
-	printf("Set NWID:off/any\n");
-      else
-	printf("Set NWID:%X\n", event->u.nwid.value);
-      break;
-    case SIOCSIWFREQ:
-    case SIOCGIWFREQ:
-      {
-	double		freq;			/* Frequency/channel */
-	int		channel = -1;		/* Converted to channel */
-	freq = iw_freq2float(&(event->u.freq));
-	if(has_range)
-	  {
-	    if(freq < KILO)
-	      /* Convert channel to frequency if possible */
-	      channel = iw_channel_to_freq((int) freq, &freq, iw_range);
-	    else
-	      /* Convert frequency to channel if possible */
-	      channel = iw_freq_to_channel(freq, iw_range);
-	  }
-	iw_print_freq(buffer, sizeof(buffer),
-		      freq, channel, event->u.freq.flags);
-	printf("%s %s\n", prefix, buffer);
-      }
-      break;
-    case SIOCSIWMODE:
-      printf("Set Mode:%s\n",
-	     iw_operation_mode[event->u.mode]);
-      break;
-    case SIOCSIWESSID:
-    case SIOCGIWESSID:
-      {
-	char essid[4 * IW_ESSID_MAX_SIZE + 1];
-	memset(essid, '\0', sizeof(essid));
-	if((event->u.essid.pointer) && (event->u.essid.length))
-	  memcpy(essid, event->u.essid.pointer, event->u.essid.length);
-	if(event->u.essid.flags)
-	  {
-	    /* Does it have an ESSID index ? */
-	    if((event->u.essid.flags & IW_ENCODE_INDEX) > 1)
-	      printf("%s ESSID:\"%s\" [%d]\n", prefix, essid,
-		     (event->u.essid.flags & IW_ENCODE_INDEX));
-	    else
-	      printf("%s ESSID:\"%s\"\n", prefix, essid);
-	  }
-	else
-	  printf("%s ESSID:off/any\n", prefix);
-      }
-      break;
-    case SIOCSIWENCODE:
-      {
-	unsigned char	key[IW_ENCODING_TOKEN_MAX];
-	if(event->u.data.pointer)
-	  memcpy(key, event->u.data.pointer, event->u.data.length);
-	else
-	  event->u.data.flags |= IW_ENCODE_NOKEY;
-	printf("Set Encryption key:");
-	if(event->u.data.flags & IW_ENCODE_DISABLED)
-	  printf("off\n");
-	else
-	  {
-	    /* Display the key */
-	    iw_print_key(buffer, sizeof(buffer), key, event->u.data.length,
-			 event->u.data.flags);
-	    printf("%s", buffer);
-
-	    /* Other info... */
-	    if((event->u.data.flags & IW_ENCODE_INDEX) > 1)
-	      printf(" [%d]", event->u.data.flags & IW_ENCODE_INDEX);
-	    if(event->u.data.flags & IW_ENCODE_RESTRICTED)
-	      printf("   Security mode:restricted");
-	    if(event->u.data.flags & IW_ENCODE_OPEN)
-	      printf("   Security mode:open");
-	    printf("\n");
-	  }
-      }
-      break;
-      /* ----- driver events ----- */
-      /* Events generated by the driver when something important happens */
-    case SIOCGIWAP:
-      printf("New Access Point/Cell address:%s\n",
-	     iw_sawap_ntop(&event->u.ap_addr, buffer));
-      break;
-    case SIOCGIWSCAN:
-      printf("Scan request completed\n");
-      break;
-    case IWEVTXDROP:
-      printf("Tx packet dropped:%s\n",
-	     iw_saether_ntop(&event->u.addr, buffer));
-      break;
-    case IWEVCUSTOM:
-      {
-	char custom[IW_CUSTOM_MAX+1];
-	memset(custom, '\0', sizeof(custom));
-	if((event->u.data.pointer) && (event->u.data.length))
-	  memcpy(custom, event->u.data.pointer, event->u.data.length);
-	printf("Custom driver event:%s\n", custom);
-      }
-      break;
-    case IWEVREGISTERED:
-      printf("Registered node:%s\n",
-	     iw_saether_ntop(&event->u.addr, buffer));
-      break;
-    case IWEVEXPIRED:
-      printf("Expired node:%s\n",
-	     iw_saether_ntop(&event->u.addr, buffer));
-      break;
-    case SIOCGIWTHRSPY:
-      {
-	struct iw_thrspy	threshold;
-	if((event->u.data.pointer) && (event->u.data.length))
-	  {
-	    memcpy(&threshold, event->u.data.pointer,
-		   sizeof(struct iw_thrspy));
-	    printf("Spy threshold crossed on address:%s\n",
-		   iw_saether_ntop(&threshold.addr, buffer));
-	    iw_print_stats(buffer, sizeof(buffer),
-			   &threshold.qual, iw_range, has_range);
-	    printf("                            Link %s\n", buffer);
-	  }
-	else
-	  printf("Invalid Spy Threshold event\n");
-      }
-      break;
-      /* ----- driver WPA events ----- */
-      /* Events generated by the driver, used for WPA operation */
-    case IWEVMICHAELMICFAILURE:
-      if(event->u.data.length >= sizeof(struct iw_michaelmicfailure))
-	{
-	  struct iw_michaelmicfailure mf;
-	  memcpy(&mf, event->u.data.pointer, sizeof(mf));
-	  printf("Michael MIC failure flags:0x%X src_addr:%s tsc:%s\n",
-		 mf.flags,
-		 iw_saether_ntop(&mf.src_addr, buffer2),
-		 iw_hexdump(buffer, sizeof(buffer),
-			    mf.tsc, IW_ENCODE_SEQ_MAX_SIZE));
-	}
-      break;
-    case IWEVASSOCREQIE:
-      printf("Association Request IEs:%s\n",
-	     iw_hexdump(buffer, sizeof(buffer),
+	char		buffer[1024];	/* Temporary buffer */
+	char		buffer2[30];	/* Temporary buffer */
+	char *	prefix = (IW_IS_GET(event->cmd) ? "New" : "Set");
+#define MGMT_FRAM_TAG_SIZE 30 /* hardcoded in driver */
+
+	/* Now, let's decode the event */
+	switch(event->cmd)
+	{
+		/* ----- set events ----- */
+		/* Events that result from a "SET XXX" operation by the user */
+		case SIOCSIWNWID:
+			if(event->u.nwid.disabled)
+				log_dbg("Set NWID:off/any\n");
+			else
+				log_dbg("Set NWID:%X\n", event->u.nwid.value);
+			break;
+		case SIOCSIWFREQ:
+		case SIOCGIWFREQ:
+		{
+			double		freq;			/* Frequency/channel */
+			int		channel = -1;		/* Converted to channel */
+			freq = iw_freq2float(&(event->u.freq));
+			if(has_range)
+			{
+				if(freq < KILO)
+				/* Convert channel to frequency if possible */
+				channel = iw_channel_to_freq((int) freq, &freq, iw_range);
+			else
+				/* Convert frequency to channel if possible */
+				channel = iw_freq_to_channel(freq, iw_range);
+			}
+			iw_print_freq(buffer, sizeof(buffer),
+			freq, channel, event->u.freq.flags);
+			log_dbg("%s %s\n", prefix, buffer);
+		}
+			break;
+		case SIOCSIWMODE:
+			log_dbg("Set Mode:%s\n",
+			iw_operation_mode[event->u.mode]);
+			break;
+		case SIOCSIWESSID:
+		case SIOCGIWESSID:
+		{
+			char essid[4 * IW_ESSID_MAX_SIZE + 1];
+			memset(essid, '\0', sizeof(essid));
+			if((event->u.essid.pointer) && (event->u.essid.length))
+				memcpy(essid, event->u.essid.pointer, event->u.essid.length);
+			if(event->u.essid.flags)
+			{
+				/* Does it have an ESSID index ? */
+				if((event->u.essid.flags & IW_ENCODE_INDEX) > 1)
+					log_dbg("%s ESSID:\"%s\" [%d]\n", prefix, essid,
+					(event->u.essid.flags & IW_ENCODE_INDEX));
+				else
+					log_dbg("%s ESSID:\"%s\"\n", prefix, essid);
+			}
+			else
+				log_dbg("%s ESSID:off/any\n", prefix);
+		}
+		break;
+		case SIOCSIWENCODE:
+		{
+			unsigned char	key[IW_ENCODING_TOKEN_MAX];
+			if(event->u.data.pointer)
+				memcpy(key, event->u.data.pointer, event->u.data.length);
+			else
+				event->u.data.flags |= IW_ENCODE_NOKEY;
+			log_dbg("Set Encryption key:");
+			if(event->u.data.flags & IW_ENCODE_DISABLED)
+				log_dbg("off\n");
+			else
+			{
+				/* Display the key */
+				iw_print_key(buffer, sizeof(buffer), key, event->u.data.length,
+				event->u.data.flags);
+				//log_dbg("%s", buffer);
+				log_dbg("%s\n", buffer);
+
+				/* Other info... */
+				if((event->u.data.flags & IW_ENCODE_INDEX) > 1)
+					//printf(" [%d]", event->u.data.flags & IW_ENCODE_INDEX);
+					log_dbg(" [%d]\n", event->u.data.flags & IW_ENCODE_INDEX);
+				if(event->u.data.flags & IW_ENCODE_RESTRICTED)
+					//printf("   Security mode:restricted");
+					log_dbg("Security mode:restricted\n");
+				if(event->u.data.flags & IW_ENCODE_OPEN)
+					//printf("   Security mode:open");
+					log_dbg("Security mode:open");
+				//printf("\n");
+			}
+		}
+		break;
+		/* ----- driver events ----- */
+		/* Events generated by the driver when something important happens */
+		case SIOCGIWAP:
+			log_dbg("New Access Point/Cell address:%s\n",
+			iw_sawap_ntop(&event->u.ap_addr, buffer));
+			break;
+		case SIOCGIWSCAN:
+			log_dbg("Scan request completed\n");
+			break;
+		case IWEVTXDROP:
+			log_dbg("Tx packet dropped:%s\n",
+			iw_saether_ntop(&event->u.addr, buffer));
+			break;
+		case IWEVASSOCREQIE:
+		case IWEVCUSTOM:
+		{
+			log_info("CUSTOM EVENT IES=%s\n",iw_hexdump(buffer, sizeof(buffer),
 			event->u.data.pointer, event->u.data.length));
-      break;
-    case IWEVASSOCRESPIE:
-      printf("Association Response IEs:%s\n",
-	     iw_hexdump(buffer, sizeof(buffer),
+			log_dbg("event->cmd=[0x%x],len=[%d]\n",event->cmd,event->len);
+
+			char * custom;
+			int len = 0;
+			//printf("\n");
+
+			custom = event->u.data.pointer;
+			memcpy(custom, event->u.data.pointer, event->u.data.length);
+			if(custom){
+				log_dbg("Custom is [%s]\n",custom);
+				if (strncmp(custom, "MLME-MICHAELMICFAILURE.indication", 33) == 0) 
+				{
+					log_dbg(":MLME-MICHAELMICFAILURE.indication\n");
+				}
+				else if (strncmp(custom, "Manage.prob_req ", 16) == 0){
+					log_dbg("Manage.prob_req\n");
+					len = atoi(custom + 16);
+					event_to_custom((u8*)custom+MGMT_FRAM_TAG_SIZE,len,event->u.data.flags,ifname);
+				}
+				else if (strncmp(custom, "Manage.auth ", 12) == 0) {
+					log_dbg("Manage.auth\n");
+					len = atoi(custom + 12);
+					event_to_custom((u8*)custom+MGMT_FRAM_TAG_SIZE,len,event->u.data.flags,ifname);
+				}
+				else if (strncmp(custom, "Manage.assoc_req ", 17) == 0) {
+					log_dbg("Manage.assoc_req\n");
+					len = atoi(custom + 17);
+					event_to_custom((u8*)custom+MGMT_FRAM_TAG_SIZE,len,event->u.data.flags,ifname);
+
+				}
+				else if (strncmp(custom, "STA-TRAFFIC-STAT", 16) == 0) {
+					log_dbg("STA-TRAFFIC-STAT\n");
+				}
+			}
+		}
+			break;
+		case IWEVREGISTERED:
+			log_dbg("Registered node:%s\n",
+			iw_saether_ntop(&event->u.addr, buffer));
+			break;
+		case IWEVEXPIRED:
+			log_dbg("Expired node:%s\n",
+			iw_saether_ntop(&event->u.addr, buffer));
+			log_info("Expired node [\033[35m%s\033[0m]\n",iw_saether_ntop(&event->u.addr, buffer));
+			log_sta_info("[VAP:%s] [STA::%s] expired\n",ifname,iw_saether_ntop(&event->u.addr, buffer));
+			break;
+		case SIOCGIWTHRSPY:
+		{
+			struct iw_thrspy	threshold;
+			if((event->u.data.pointer) && (event->u.data.length))
+			{
+				memcpy(&threshold, event->u.data.pointer,
+				sizeof(struct iw_thrspy));
+				log_dbg("Spy threshold crossed on address:%s\n",
+				iw_saether_ntop(&threshold.addr, buffer));
+				iw_print_stats(buffer, sizeof(buffer),
+				&threshold.qual, iw_range, has_range);
+				log_dbg("                            Link %s\n", buffer);
+			}
+			else
+				log_dbg("Invalid Spy Threshold event\n");
+		}
+		break;
+
+		/* ----- driver WPA events ----- */
+		/* Events generated by the driver, used for WPA operation */
+		case IWEVMICHAELMICFAILURE:
+			if(event->u.data.length >= sizeof(struct iw_michaelmicfailure))
+			{
+				struct iw_michaelmicfailure mf;
+				memcpy(&mf, event->u.data.pointer, sizeof(mf));
+				log_dbg("Michael MIC failure flags:0x%X src_addr:%s tsc:%s\n",
+				mf.flags,
+				iw_saether_ntop(&mf.src_addr, buffer2),
+				iw_hexdump(buffer, sizeof(buffer),
+				mf.tsc, IW_ENCODE_SEQ_MAX_SIZE));
+			}
+		break;
+#if 0	  
+		case IWEVASSOCREQIE:
+		log_dbg("Association Request IEs:%s\n",
+		iw_hexdump(buffer, sizeof(buffer),
+		event->u.data.pointer, event->u.data.length));
+		break;
+#endif
+		case IWEVASSOCRESPIE:
+			log_dbg("Association Response IEs:%s\n",
+			iw_hexdump(buffer, sizeof(buffer),
 			event->u.data.pointer, event->u.data.length));
-      break;
-    case IWEVPMKIDCAND:
-      if(event->u.data.length >= sizeof(struct iw_pmkid_cand))
-	{
-	  struct iw_pmkid_cand cand;
-	  memcpy(&cand, event->u.data.pointer, sizeof(cand));
-	  printf("PMKID candidate flags:0x%X index:%d bssid:%s\n",
-		 cand.flags, cand.index,
-		 iw_saether_ntop(&cand.bssid, buffer));
-	}
-      break;
-      /* ----- junk ----- */
-      /* other junk not currently in use */
-    case SIOCGIWRATE:
-      iw_print_bitrate(buffer, sizeof(buffer), event->u.bitrate.value);
-      printf("New Bit Rate:%s\n", buffer);
-      break;
-    case SIOCGIWNAME:
-      printf("Protocol:%-1.16s\n", event->u.name);
-      break;
-    case IWEVQUAL:
-      {
-	event->u.qual.updated = 0x0;	/* Not that reliable, disable */
-	iw_print_stats(buffer, sizeof(buffer),
-		       &event->u.qual, iw_range, has_range);
-	printf("Link %s\n", buffer);
-	break;
-      }
-    default:
-      printf("(Unknown Wireless event 0x%04X)\n", event->cmd);
-    }	/* switch(event->cmd) */
+			break;
+		case IWEVPMKIDCAND:
+			if(event->u.data.length >= sizeof(struct iw_pmkid_cand))
+			{
+				struct iw_pmkid_cand cand;
+				memcpy(&cand, event->u.data.pointer, sizeof(cand));
+				log_dbg("PMKID candidate flags:0x%X index:%d bssid:%s\n",
+				cand.flags, cand.index,
+				iw_saether_ntop(&cand.bssid, buffer));
+			}
+			break;
+		/* ----- junk ----- */
+		/* other junk not currently in use */
+		case SIOCGIWRATE:
+			iw_print_bitrate(buffer, sizeof(buffer), event->u.bitrate.value);
+			log_dbg("New Bit Rate:%s\n", buffer);
+			break;
+		case SIOCGIWNAME:
+			log_dbg("Protocol:%-1.16s\n", event->u.name);
+			break;
+		case IWEVQUAL:
+		{
+			event->u.qual.updated = 0x0;	/* Not that reliable, disable */
+			iw_print_stats(buffer, sizeof(buffer),
+			&event->u.qual, iw_range, has_range);
+			log_dbg("Link %s\n", buffer);
+			break;
+		}
+		default:
+			log_dbg("(Unknown Wireless event 0x%04X)\n", event->cmd);
+	}	/* switch(event->cmd) */
 
   return(0);
 }
@@ -502,48 +630,49 @@
 		   char *	data,
 		   int		len)
 {
-  struct iw_event	iwe;
-  struct stream_descr	stream;
-  int			i = 0;
-  int			ret;
-  char			buffer[64];
-  struct timeval	recv_time;
-  struct timezone	tz;
-  struct wireless_iface *	wireless_data;
-
-  /* Get data from cache */
-  wireless_data = iw_get_interface_data(ifindex);
-  if(wireless_data == NULL)
-    return(-1);
-
-  /* Print received time in readable form */
-  gettimeofday(&recv_time, &tz);
-  iw_print_timeval(buffer, sizeof(buffer), &recv_time, &tz);
-
-  iw_init_event_stream(&stream, data, len);
-  do
-    {
-      /* Extract an event and print it */
-      ret = iw_extract_event_stream(&stream, &iwe,
-				    wireless_data->range.we_version_compiled);
-      if(ret != 0)
-	{
-	  if(i++ == 0)
-	    printf("%s   %-8.16s ", buffer, wireless_data->ifname);
-	  else
-	    printf("                           ");
-	  if(ret > 0)
-	    print_event_token(&iwe,
-			      &wireless_data->range, wireless_data->has_range);
-	  else
-	    printf("(Invalid event)\n");
-	  /* Push data out *now*, in case we are redirected to a pipe */
-	  fflush(stdout);
-	}
-    }
-  while(ret > 0);
+	struct iw_event	iwe;
+	struct stream_descr	stream;
+	int			i = 0;
+	int			ret;
+	char			buffer[64];
+	struct timeval	recv_time;
+	struct timezone	tz;
+	struct wireless_iface *	wireless_data;
+
+	/* Get data from cache */
+	wireless_data = iw_get_interface_data(ifindex);
+	if(wireless_data == NULL)
+		return(-1);
+
+	/* Print received time in readable form */
+	gettimeofday(&recv_time, &tz);
+	iw_print_timeval(buffer, sizeof(buffer), &recv_time, &tz);
+
+	iw_init_event_stream(&stream, data, len);
+	do
+	{
+		/* Extract an event and print it */
+		ret = iw_extract_event_stream(&stream, &iwe,
+		wireless_data->range.we_version_compiled);
+		if(ret != 0)
+		{
+			if(i++ == 0)
+			//printf("%s  %-8.16s ", buffer, wireless_data->ifname);
+			log_dbg("%s  %-8.16s\n", buffer, wireless_data->ifname);
+			else
+				//printf("                           ");
+				log_dbg("   ");
+			if(ret > 0)
+				print_event_token(&iwe,
+				&wireless_data->range, wireless_data->has_range,wireless_data->ifname);
+			else
+				log_dbg("(Invalid event)\n");
+			/* Push data out *now*, in case we are redirected to a pipe */
+			// nickli //fflush(stdout);
+		}
+	}while(ret > 0);
 
-  return(0);
+	return(0);
 }
 
 /*********************** RTNETLINK EVENT DUMP***********************/
@@ -559,47 +688,47 @@
 static int
 LinkCatcher(struct nlmsghdr *nlh)
 {
-  struct ifinfomsg* ifi;
+	struct ifinfomsg* ifi;
 
 #if 0
-  fprintf(stderr, "nlmsg_type = %d.\n", nlh->nlmsg_type);
+	fprintf(stderr, "nlmsg_type = %d.\n", nlh->nlmsg_type);
 #endif
 
-  ifi = NLMSG_DATA(nlh);
-
-  /* Code is ugly, but sort of works - Jean II */
+	ifi = NLMSG_DATA(nlh);
 
-  /* If interface is getting destoyed */
-  if(nlh->nlmsg_type == RTM_DELLINK)
-    {
-      /* Remove from cache (if in cache) */
-      iw_del_interface_data(ifi->ifi_index);
-      return 0;
-    }
+	/* Code is ugly, but sort of works - Jean II */
 
-  /* Only keep add/change events */
-  if(nlh->nlmsg_type != RTM_NEWLINK)
-    return 0;
-
-  /* Check for attributes */
-  if (nlh->nlmsg_len > NLMSG_ALIGN(sizeof(struct ifinfomsg)))
-    {
-      int attrlen = nlh->nlmsg_len - NLMSG_ALIGN(sizeof(struct ifinfomsg));
-      struct rtattr *attr = (void *) ((char *) ifi +
-				      NLMSG_ALIGN(sizeof(struct ifinfomsg)));
-
-      while (RTA_OK(attr, attrlen))
-	{
-	  /* Check if the Wireless kind */
-	  if(attr->rta_type == IFLA_WIRELESS)
-	    {
-	      /* Go to display it */
-	      print_event_stream(ifi->ifi_index,
-				 (char *) attr + RTA_ALIGN(sizeof(struct rtattr)),
-				 attr->rta_len - RTA_ALIGN(sizeof(struct rtattr)));
-	    }
-	  attr = RTA_NEXT(attr, attrlen);
-	}
+	/* If interface is getting destoyed */
+	if(nlh->nlmsg_type == RTM_DELLINK)
+	{
+		/* Remove from cache (if in cache) */
+		iw_del_interface_data(ifi->ifi_index);
+		return 0;
+	}
+
+	/* Only keep add/change events */
+	if(nlh->nlmsg_type != RTM_NEWLINK)
+		return 0;
+
+	/* Check for attributes */
+	if (nlh->nlmsg_len > NLMSG_ALIGN(sizeof(struct ifinfomsg)))
+	{
+		int attrlen = nlh->nlmsg_len - NLMSG_ALIGN(sizeof(struct ifinfomsg));
+		struct rtattr *attr = (void *) ((char *) ifi +
+			NLMSG_ALIGN(sizeof(struct ifinfomsg)));
+
+		while (RTA_OK(attr, attrlen))
+		{
+			/* Check if the Wireless kind */
+			if(attr->rta_type == IFLA_WIRELESS)
+			{
+				/* Go to display it */
+				print_event_stream(ifi->ifi_index,
+					(char *) attr + RTA_ALIGN(sizeof(struct rtattr)),
+					attr->rta_len - RTA_ALIGN(sizeof(struct rtattr)));
+			}
+			attr = RTA_NEXT(attr, attrlen);
+		}
     }
 
   return 0;
@@ -614,65 +743,65 @@
 static inline void
 handle_netlink_events(struct rtnl_handle *	rth)
 {
-  while(1)
-    {
-      struct sockaddr_nl sanl;
-      socklen_t sanllen = sizeof(struct sockaddr_nl);
-
-      struct nlmsghdr *h;
-      int amt;
-      char buf[8192];
-
-      amt = recvfrom(rth->fd, buf, sizeof(buf), MSG_DONTWAIT, (struct sockaddr*)&sanl, &sanllen);
-      if(amt < 0)
-	{
-	  if(errno != EINTR && errno != EAGAIN)
-	    {
-	      fprintf(stderr, "%s: error reading netlink: %s.\n",
-		      __PRETTY_FUNCTION__, strerror(errno));
-	    }
-	  return;
-	}
-
-      if(amt == 0)
-	{
-	  fprintf(stderr, "%s: EOF on netlink??\n", __PRETTY_FUNCTION__);
-	  return;
-	}
-
-      h = (struct nlmsghdr*)buf;
-      while(amt >= (int)sizeof(*h))
-	{
-	  int len = h->nlmsg_len;
-	  int l = len - sizeof(*h);
-
-	  if(l < 0 || len > amt)
-	    {
-	      fprintf(stderr, "%s: malformed netlink message: len=%d\n", __PRETTY_FUNCTION__, len);
-	      break;
-	    }
-
-	  switch(h->nlmsg_type)
-	    {
-	    case RTM_NEWLINK:
-	    case RTM_DELLINK:
-	      LinkCatcher(h);
-	      break;
-	    default:
+	while(1)
+	{
+		struct sockaddr_nl sanl;
+		socklen_t sanllen = sizeof(struct sockaddr_nl);
+
+		struct nlmsghdr *h;
+		int amt;
+		char buf[8192];
+
+		amt = recvfrom(rth->fd, buf, sizeof(buf), MSG_DONTWAIT, (struct sockaddr*)&sanl, &sanllen);
+		if(amt < 0)
+			{
+			if(errno != EINTR && errno != EAGAIN)
+			{
+				fprintf(stderr, "%s: error reading netlink: %s.\n",
+					__PRETTY_FUNCTION__, strerror(errno));
+			}
+			return;
+		}
+
+		if(amt == 0)
+		{
+			fprintf(stderr, "%s: EOF on netlink??\n", __PRETTY_FUNCTION__);
+			return;
+		}
+
+		h = (struct nlmsghdr*)buf;
+		while(amt >= (int)sizeof(*h))
+		{
+			int len = h->nlmsg_len;
+			int l = len - sizeof(*h);
+
+			if(l < 0 || len > amt)
+			{
+				fprintf(stderr, "%s: malformed netlink message: len=%d\n", __PRETTY_FUNCTION__, len);
+				break;
+			}
+
+			switch(h->nlmsg_type)
+			{
+				case RTM_NEWLINK:
+				case RTM_DELLINK:
+					LinkCatcher(h);
+					break;
+				default:
 #if 0
-	      fprintf(stderr, "%s: got nlmsg of type %#x.\n", __PRETTY_FUNCTION__, h->nlmsg_type);
+					fprintf(stderr, "%s: got nlmsg of type %#x.\n", __PRETTY_FUNCTION__, h->nlmsg_type);
 #endif
-	      break;
-	    }
+					break;
+			}
 
-	  len = NLMSG_ALIGN(len);
-	  amt -= len;
-	  h = (struct nlmsghdr*)((char*)h + len);
-	}
+			len = NLMSG_ALIGN(len);
+			amt -= len;
+			h = (struct nlmsghdr*)((char*)h + len);
+		}
 
-      if(amt > 0)
-	fprintf(stderr, "%s: remnant of size %d on netlink\n", __PRETTY_FUNCTION__, amt);
-    }
+		if(amt > 0)
+			fprintf(stderr, "%s: remnant of size %d on netlink\n", __PRETTY_FUNCTION__, amt);
+	}
 }
 
 /**************************** MAIN LOOP ****************************/
@@ -685,45 +814,45 @@
 wait_for_event(struct rtnl_handle *	rth)
 {
 #if 0
-  struct timeval	tv;	/* Select timeout */
+	struct timeval	tv;	/* Select timeout */
 #endif
 
-  /* Forever */
-  while(1)
-    {
-      fd_set		rfds;		/* File descriptors for select */
-      int		last_fd;	/* Last fd */
-      int		ret;
-
-      /* Guess what ? We must re-generate rfds each time */
-      FD_ZERO(&rfds);
-      FD_SET(rth->fd, &rfds);
-      last_fd = rth->fd;
-
-      /* Wait until something happens */
-      ret = select(last_fd + 1, &rfds, NULL, NULL, NULL);
-
-      /* Check if there was an error */
-      if(ret < 0)
-	{
-	  if(errno == EAGAIN || errno == EINTR)
-	    continue;
-	  fprintf(stderr, "Unhandled signal - exiting...\n");
-	  break;
-	}
-
-      /* Check if there was a timeout */
-      if(ret == 0)
+	/* Forever */
+	while(1)
 	{
-	  continue;
+		fd_set		rfds;		/* File descriptors for select */
+		int		last_fd;	/* Last fd */
+		int		ret;
+
+		/* Guess what ? We must re-generate rfds each time */
+		FD_ZERO(&rfds);
+		FD_SET(rth->fd, &rfds);
+		last_fd = rth->fd;
+
+		/* Wait until something happens */
+		ret = select(last_fd + 1, &rfds, NULL, NULL, NULL);
+
+		/* Check if there was an error */
+		if(ret < 0)
+		{
+			if(errno == EAGAIN || errno == EINTR)
+				continue;
+			fprintf(stderr, "Unhandled signal - exiting...\n");
+			break;
+		}
+
+		/* Check if there was a timeout */
+		if(ret == 0)
+		{
+			continue;
+		}
+
+		/* Check for interface discovery events. */
+		if(FD_ISSET(rth->fd, &rfds))
+			handle_netlink_events(rth);
 	}
 
-      /* Check for interface discovery events. */
-      if(FD_ISSET(rth->fd, &rfds))
-	handle_netlink_events(rth);
-    }
-
-  return(0);
+	return(0);
 }
 
 /******************************* MAIN *******************************/
@@ -735,70 +864,73 @@
 static void
 iw_usage(int status)
 {
-  fputs("Usage: iwevent [OPTIONS]\n"
-	"   Monitors and displays Wireless Events.\n"
-	"   Options are:\n"
-	"     -h,--help     Print this message.\n"
-	"     -v,--version  Show version of this program.\n",
-	status ? stderr : stdout);
-  exit(status);
+	fputs("Usage: iwevent [OPTIONS]\n"
+		"   Monitors and displays Wireless Events.\n"
+		"   Options are:\n"
+		"     -h,--help     Print this message.\n"
+		"     -v,--version  Show version of this program.\n",
+		status ? stderr : stdout);
+	exit(status);
 }
 /* Command line options */
 static const struct option long_opts[] = {
-  { "help", no_argument, NULL, 'h' },
-  { "version", no_argument, NULL, 'v' },
-  { NULL, 0, NULL, 0 }
+	{ "help", no_argument, NULL, 'h' },
+	{ "version", no_argument, NULL, 'v' },
+	{ NULL, 0, NULL, 0 }
 };
 
 /* ---------------------------------------------------------------- */
 /*
  * main body of the program
  */
-int
-main(int	argc,
-     char *	argv[])
-{
-  struct rtnl_handle	rth;
-  int opt;
-
-  /* Check command line options */
-  while((opt = getopt_long(argc, argv, "hv", long_opts, NULL)) > 0)
-    {
-      switch(opt)
-	{
-	case 'h':
-	  iw_usage(0);
-	  break;
-
-	case 'v':
-	  return(iw_print_version_info("iwevent"));
-	  break;
-
-	default:
-	  iw_usage(1);
-	  break;
+int main( int argc, char * argv[] )
+{
+	struct rtnl_handle	rth;
+	int opt;
+
+	log_dbg_init();
+
+	log_stainfo_init();
+
+	/* Check command line options */
+	while((opt = getopt_long(argc, argv, "hv", long_opts, NULL)) > 0)
+	{
+		switch(opt)
+		{
+			case 'h':
+				iw_usage(0);
+				break;
+
+			case 'v':
+				return(iw_print_version_info("iwevent"));
+				break;
+
+			default:
+				iw_usage(1);
+				break;
+		}
+	}
+	if(optind < argc)
+	{
+		fputs("Too many arguments.\n", stderr);
+		iw_usage(1);
 	}
-    }
-  if(optind < argc)
-    {
-      fputs("Too many arguments.\n", stderr);
-      iw_usage(1);
-    }
 
-  /* Open netlink channel */
-  if(rtnl_open(&rth, RTMGRP_LINK) < 0)
-    {
-      perror("Can't initialize rtnetlink socket");
-      return(1);
-    }
+	/* Open netlink channel */
+	if(rtnl_open(&rth, RTMGRP_LINK) < 0)
+	{
+		perror("Can't initialize rtnetlink socket");
+		return(1);
+	}
 
-  fprintf(stderr, "Waiting for Wireless Events from interfaces...\n");
+	//fprintf(stderr, "Waiting for Wireless Events from interfaces...\n");
+	log_dbg( "Waiting for Wireless Events from interfaces...\n" );
 
-  /* Do what we have to do */
-  wait_for_event(&rth);
+	/* Do what we have to do */
+	wait_for_event(&rth);
 
-  /* Cleanup - only if you are pedantic */
-  rtnl_close(&rth);
+	/* Cleanup - only if you are pedantic */
+	rtnl_close(&rth);
 
-  return(0);
+	return(0);
 }
